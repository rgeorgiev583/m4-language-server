use super::ast::*;

pub source -> Source = tokens:token* { Source { tokens } }

whitespace = [ \n\t]
literal_char = .

macro_name = [_0-9A-Za-z]+
in_macro_char = [^(),]
start_quote = "`"
end_quote = "'"
quoted_string_char = [^`']
comment_delimiter = "#"
comment_char = [^\n]

macro_arg_token -> Token =
    syntax:syntax_token { Token::Syntax(syntax) } /
    literal_string:$(in_macro_char) { Token::LiteralString(literal_string.to_string()) }

macro_arg -> Source = tokens:macro_arg_token* { Source {tokens} }

macro_invocation -> MacroInvocationToken =
    name:$(macro_name) "(" whitespace* args:(macro_arg ** ",") ")" {
        MacroInvocationToken {
            name: name.to_string(),
            args: args,
        }
    } /
    name:$(macro_name) {
        MacroInvocationToken {
            name: name.to_string(),
            args: vec![],
        }
    }

quoted_string -> String = start_quote contents:$(quoted_string_char*) end_quote { contents.to_string() }

comment -> String = comment_delimiter literal_string:$(comment_char*) "\n" { literal_string.to_string() }

syntax_token -> SyntaxToken =
    invocation:macro_invocation { SyntaxToken::MacroInvocation(invocation) } /
    literal_string:quoted_string { SyntaxToken::QuotedString(literal_string) } /
    literal_string:comment { SyntaxToken::Comment(literal_string) }

token -> Token =
    syntax:syntax_token { Token::Syntax(syntax) } /
    literal_string:$(literal_char) { Token::LiteralString(literal_string.to_string()) }